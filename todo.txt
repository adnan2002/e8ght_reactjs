
based on the api below, I want you to create the minimum required form for creating a form in FreelancerForm.jsx. validate the inputs coming from the user and make a authenticated POST request to the
endpoint. make sure to handle all the error statuses.






route: "/users/me/freelancer/"
request type: POST
method:
type createFreelancerRequest struct {
	IsAcceptingOrders bool      `json:"is_accepting_orders" binding:"required,boolean"`
	IsPublic          bool      `json:"is_public" binding:"required,boolean"`
	Bio               *string   `json:"bio" binding:"omitempty,min=10"`
	YearsOfExperience int32       `json:"years_of_experience" binding:"required,min=0"`
	Certifications    *[]string `json:"certifications" binding:"omitempty"`
	CprFrontUrl       *string   `json:"cpr_front_url" binding:"omitempty,url"`
	CprBackUrl        *string   `json:"cpr_back_url" binding:"omitempty,url"`
	PassportUrl       *string   `json:"passport_url" binding:"omitempty,url"`
	SelfiePhotoUrl    *string   `json:"selfie_photo_url" binding:"omitempty,url"`
}

func (s *Server) createFreelancerHandler(c *gin.Context) {
	payloadVal, ok := c.Get(authenticatedPayload)
	if !ok {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
		return
	}
	payload := payloadVal.(token.Payload)
	userID := payload.UserID

	if payload.Role != "freelancer" {
		c.JSON(http.StatusForbidden, gin.H{"error": "unauthorized"})
		return
	}

	var req createFreelancerRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	var bio pgtype.Text
	var certifications []string
	var cprFrontUrl pgtype.Text
	var cprBackUrl pgtype.Text
	var passportUrl pgtype.Text
	var selfiePhotoUrl pgtype.Text

	if req.Bio != nil && strings.TrimSpace(*req.Bio) != "" {
		bio = pgtype.Text{String: *req.Bio, Valid: true}
	} else {
		bio = pgtype.Text{String: "", Valid: false}
	}

	if req.Certifications != nil && len(*req.Certifications) > 0 {
		certifications = *req.Certifications
	} else {
		certifications = nil
	}

	if req.CprFrontUrl != nil && strings.TrimSpace(*req.CprFrontUrl) != "" {
		cprFrontUrl = pgtype.Text{String: *req.CprFrontUrl, Valid: true}
	} else {
		cprFrontUrl = pgtype.Text{String: "", Valid: false}
	}
	if req.CprBackUrl != nil && strings.TrimSpace(*req.CprBackUrl) != "" {
		cprBackUrl = pgtype.Text{String: *req.CprBackUrl, Valid: true}
	} else {
		cprBackUrl = pgtype.Text{String: "", Valid: false}
	}
	if req.PassportUrl != nil && strings.TrimSpace(*req.PassportUrl) != "" {
		passportUrl = pgtype.Text{String: *req.PassportUrl, Valid: true}
	} else {
		passportUrl = pgtype.Text{String: "", Valid: false}
	}
	if req.SelfiePhotoUrl != nil && strings.TrimSpace(*req.SelfiePhotoUrl) != "" {
		selfiePhotoUrl = pgtype.Text{String: *req.SelfiePhotoUrl, Valid: true}
	} else {
		selfiePhotoUrl = pgtype.Text{String: "", Valid: false}
	}


	freelancer, err := s.Store.CreateFreelancer(c, db.CreateFreelancerParams{
		UserID:            userID,
		IsAcceptingOrders: req.IsAcceptingOrders,
		IsPublic:          req.IsPublic,
		Bio:               bio,
		YearsOfExperience: req.YearsOfExperience,
		Certifications:    certifications,
		CprFrontUrl:       cprFrontUrl,
		CprBackUrl:        cprBackUrl,
		PassportUrl:       passportUrl,
		SelfiePhotoUrl:    selfiePhotoUrl,
	})
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusCreated, gin.H{"freelancer": freelancer})
}

response: {
	"freelancer": ...
}