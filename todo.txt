I want you to create an page just for the address itself. you have the address list and the users can click on one of them, of course in the params it will include the id of the address.

you need to check if the address belongs to the user, if he is not send him to dashboard page. to check if the address does not belong to the user, it will either be a status internal server error or forbidden.

anyway, in the page, if the address belongs to the user, he can edit some fields (update), or delete the address.

if the user decides to delete the address send him back to the address list page.


here are the apis you will need.


1-
route: "/users/me/addresses/:id"
request type: GET
method:
type getAddressByIDRequest struct {
	ID int64 `uri:"id" binding:"required,min=1"`
}

func (s *Server) getAddressByIDHandler(c *gin.Context) {
	payloadVal, ok := c.Get(authenticatedPayload)
	if !ok {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
		return
	}
	payload := payloadVal.(token.Payload)
	userID := payload.UserID

	var req getAddressByIDRequest
	if err := c.ShouldBindUri(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	address, err := s.Store.GetAddressByIDAndUserID(c, db.GetAddressByIDAndUserIDParams{
		ID:     req.ID,
		UserID: userID,
	})
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to get address"})
		return
	}
	if address.UserID != userID {
		c.JSON(http.StatusForbidden, gin.H{"error": "unauthorized"})
		return
	}
	c.JSON(http.StatusOK, gin.H{"address": address})
}

response:
"address": {
	id
	user_id
	address_label
	address_type
	address_line_1
	address_line_2
	town
	governorate
	country
	road_number
	latitude
	longitude
	additional_directions
	is_default
	created_at
	updated_at
}


2- 
route: "/users/me/addresses/:id"
request type: PATCH
method:
type patchAddressRequest struct {
	AddressLabel         *string  `json:"address_label" binding:"omitempty,min=2"`
	AddressType          *string  `json:"address_type" binding:"omitempty,oneof=house office apartment"`
	AddressLine1         *string  `json:"address_line_1" binding:"omitempty,min=2"`
	AddressLine2         *string  `json:"address_line_2" binding:"omitempty"`
	Town                 *string  `json:"town" binding:"omitempty"`
	Governorate          *string  `json:"governorate" binding:"omitempty"`
	Country              *string  `json:"country" binding:"omitempty"`
	RoadNumber           *string  `json:"road_number" binding:"omitempty"`
	Latitude             *float64 `json:"latitude" binding:"omitempty,latitude"`
	Longitude            *float64 `json:"longitude" binding:"omitempty,longitude"`
	AdditionalDirections *string  `json:"additional_directions" binding:"omitempty"`
}

func (s *Server) patchAddressHandler(c *gin.Context) {
	payloadVal, ok := c.Get(authenticatedPayload)
	if !ok {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
		return
	}
	payload := payloadVal.(token.Payload)
	userID := payload.UserID

	var uri getAddressByIDRequest
	if err := c.ShouldBindUri(&uri); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Ensure the address belongs to the authenticated user
	address, err := s.Store.GetAddressByIDAndUserID(c, db.GetAddressByIDAndUserIDParams{
		ID:     uri.ID,
		UserID: userID,
	})
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to get address"})
		return
	}
	if address.UserID != userID {
		c.JSON(http.StatusForbidden, gin.H{"error": "unauthorized"})
		return
	}

	var req patchAddressRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Build partial update params
	var (
		addrLabel pgtype.Text
		addrType  db.NullAddressType
		line1     pgtype.Text
		line2     pgtype.Text
		town      pgtype.Text
		gov       pgtype.Text
		country   pgtype.Text
		road      pgtype.Text
		lat       pgtype.Numeric
		lon       pgtype.Numeric
		addDir    pgtype.Text
	)

	if req.AddressLabel != nil {
		addrLabel = pgtype.Text{String: *req.AddressLabel, Valid: true}
	}
	if req.AddressType != nil {
		addrType = db.NullAddressType{AddressType: db.AddressType(*req.AddressType), Valid: true}
	}
	if req.AddressLine1 != nil {
		line1 = pgtype.Text{String: *req.AddressLine1, Valid: true}
	}
	if req.AddressLine2 != nil {
		line2 = pgtype.Text{String: *req.AddressLine2, Valid: true}
	}
	if req.Town != nil {
		town = pgtype.Text{String: *req.Town, Valid: true}
	}
	if req.Governorate != nil {
		gov = pgtype.Text{String: *req.Governorate, Valid: true}
	}
	if req.Country != nil {
		country = pgtype.Text{String: *req.Country, Valid: true}
	}
	if req.RoadNumber != nil {
		road = pgtype.Text{String: *req.RoadNumber, Valid: true}
	}
	if req.Latitude != nil {
		latText := strconv.FormatFloat(*req.Latitude, 'f', 8, 64)
		if err := lat.Scan(latText); err != nil {
			c.JSON(http.StatusBadRequest, gin.H{"error": "invalid latitude"})
			return
		}
	}
	if req.Longitude != nil {
		lonText := strconv.FormatFloat(*req.Longitude, 'f', 8, 64)
		if err := lon.Scan(lonText); err != nil {
			c.JSON(http.StatusBadRequest, gin.H{"error": "invalid longitude"})
			return
		}
	}
	if req.AdditionalDirections != nil {
		addDir = pgtype.Text{String: *req.AdditionalDirections, Valid: true}
	}

	updated, err := s.Store.UpdateAddressPartial(c, db.UpdateAddressPartialParams{
		AddressLabel:         addrLabel,
		AddressType:          addrType,
		AddressLine1:         line1,
		AddressLine2:         line2,
		Town:                 town,
		Governorate:          gov,
		Country:              country,
		RoadNumber:           road,
		Latitude:             lat,
		Longitude:            lon,
		AdditionalDirections: addDir,
		ID:                   uri.ID,
	})
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to update address"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"address": updated})
}

response:
"address": {
	id
	user_id
	address_label
	address_type
	address_line_1
	address_line_2
	town
	governorate
	country
	road_number
	latitude
	longitude
	additional_directions
	is_default
	created_at
	updated_at
}


3- 
route: "/users/me/addresses/:id"
request type: DELETE
method:
type getAddressByIDRequest struct {
	ID int64 `uri:"id" binding:"required,min=1"`
}

func (s *Server) deleteAddressHandler(c *gin.Context) {
	payloadVal, ok := c.Get(authenticatedPayload)
	if !ok {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
		return
	}
	payload := payloadVal.(token.Payload)
	userID := payload.UserID

	var uri getAddressByIDRequest
	if err := c.ShouldBindUri(&uri); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	if err := s.Store.ExecTx(c, func(q *db.Queries) error {
		addr, err := q.GetAddressByIDAndUserID(c, db.GetAddressByIDAndUserIDParams{
			ID:     uri.ID,
			UserID: userID,
		})
		if err != nil {
			return err
		}

		if err := q.DeleteAddressByID(c, uri.ID); err != nil {
			return err
		}

		if addr.IsDefault {
			newestID, err := q.GetNewestAddressIDForUser(c, userID)
			if err == nil {
				if _, err := q.SetDefaultAddressForUser(c, db.SetDefaultAddressForUserParams{ID: newestID, UserID: userID}); err != nil {
					return err
				}
			} else if err != pgx.ErrNoRows {
				return err
			}
		}
		return nil
	}); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to delete address"})
		return
	}

	c.Status(http.StatusNoContent)
}

No content response