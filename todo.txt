I want you to expand the freelancer form page, instead of redirecting, the user will be shown "next step", where the user will show the create services component. the user can add up to 10 services (max) if he wants and minimum 1. This step can only be shown once the first step (freelancer creation) has been successful. make the form very simple in terms of ui. analyze the input checks made in method section written in go, to validate the user input and alert the user if he is inputting the correct type of data. once everything is good, make a POST request using the useAuthenticatedFetch hook to the api endpoint below, if the response is successful, make sure to include it in the context of the application. after that, redirect the user to dashboard/freelancer just like before. 



CREATE TABLE "service_categories" (
  "id" bigserial PRIMARY KEY,
  "name" text NOT NULL
);


CREATE INDEX ON "service_categories" ("name");


INSERT INTO service_categories (name) VALUES
  ('Hair'),
  ('Nails'),
  ('Makeup'),
  ('Skincare'),
  ('Lashes & Brows'),
  ('Body & Spa'),
  ('Health & Fitness'),
  ('Waxing & Hair Removal'),
  ('Massage & Wellness'),
  ('Bridal Services');

this the schema for services_categories, they are constant, so just hard code them.



route: "/users/me/freelancer/services/"
request type: POST
hook to use: useAuthenticatedFetch
method:
type createFreelancerServicesRequest struct {
	ServiceCategoryID      int64    `json:"service_category_id" binding:"required,min=1"`
	Title                  string   `json:"title" binding:"required,min=2"`
	Description            string   `json:"description" binding:"required,min=10"`
	Pricing                string   `json:"pricing" binding:"required,oneof=fixed range"`
	FixedPrice             float64  `json:"fixed_price" binding:"omitempty,gt=0"`
	ServiceDurationSeconds int32    `json:"service_duration_seconds" binding:"required,min=3600"`
	MinPrice               float64  `json:"min_price" binding:"omitempty,gt=0"`
	MaxPrice               float64  `json:"max_price" binding:"omitempty,gt=min_price"`
	ProductsUsed           []string `json:"products_used" binding:"omitempty"`
	Location               string   `json:"location" binding:"required,oneof=on_premise door_step"`
}

func (s *Server) createFreelancerServicesHandler(c *gin.Context) {
	payloadVal, ok := c.Get(authenticatedPayload)
	if !ok {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
		return
	}
	payload := payloadVal.(token.Payload)
	userID := payload.UserID

	if payload.Role != "freelancer" {
		c.JSON(http.StatusForbidden, gin.H{"error": "unauthorized"})
		return
	}

	freelancer, err := s.Store.GetFreelancerByUserID(c, userID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	if freelancer.ID == 0 {
		c.JSON(http.StatusNotFound, gin.H{"error": "freelancer not found"})
		return
	}

	var req []createFreelancerServicesRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, errorResponse(err))
		return
	}

	if len(req) == 0 {
		c.JSON(http.StatusBadRequest, gin.H{"error": "at least one service is required"})
		return
	}
	if len(req) > 10 {
		c.JSON(http.StatusBadRequest, gin.H{"error": "maximum of 10 services are allowed"})
		return
	}

	services := make([]db.FreelancerService, len(req))
	var validationErr error
	err = s.Store.ExecTx(c, func(q *db.Queries) error {
		for i, service := range req {
			switch service.Pricing {
			case "fixed":
				if service.FixedPrice <= 0 {
					validationErr = errors.New("fixed price must be greater than zero for fixed pricing")
					return validationErr
				}
				if service.MinPrice > 0 || service.MaxPrice > 0 {
					validationErr = errors.New("min and max price must be omitted for fixed pricing")
					return validationErr
				}
			case "range":
				if service.MinPrice <= 0 || service.MaxPrice <= 0 {
					validationErr = errors.New("min and max price must be greater than zero for range pricing")
					return validationErr
				}
				if service.MaxPrice <= service.MinPrice {
					validationErr = errors.New("max price must be greater than min price for range pricing")
					return validationErr
				}
				if service.FixedPrice > 0 {
					validationErr = errors.New("fixed price must be omitted for range pricing")
					return validationErr
				}
			default:
				validationErr = errors.New("invalid pricing type")
				return validationErr
			}

			var fixedPrice pgtype.Numeric
			if service.FixedPrice > 0 {
				if err := fixedPrice.Scan(strconv.FormatFloat(service.FixedPrice, 'f', 2, 64)); err != nil {
					return err
				}
			}

			var minPrice pgtype.Numeric
			if service.MinPrice > 0 {
				if err := minPrice.Scan(strconv.FormatFloat(service.MinPrice, 'f', 2, 64)); err != nil {
					return err
				}
			}

			var maxPrice pgtype.Numeric
			if service.MaxPrice > 0 {
				if err := maxPrice.Scan(strconv.FormatFloat(service.MaxPrice, 'f', 2, 64)); err != nil {
					return err
				}
			}

			services[i], err = q.CreateFreelancerService(c, db.CreateFreelancerServiceParams{
				FreelancerID:           freelancer.ID,
				ServiceCategoryID:      service.ServiceCategoryID,
				Title:                  service.Title,
				Description:            service.Description,
				Pricing:                db.FreelancerPricing(service.Pricing),
				FixedPrice:             fixedPrice,
				ServiceDurationSeconds: service.ServiceDurationSeconds,
				MinPrice:               minPrice,
				MaxPrice:               maxPrice,
				ProductsUsed:           service.ProductsUsed,
				Location:               db.ServiceLocation(service.Location),
			})
			if err != nil {
				return err
			}
		}
		return nil
	})
	if validationErr != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": validationErr.Error()})
		return
	}
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}
	c.JSON(http.StatusCreated, gin.H{"services": services})
}
response:{
"services": ...
}



validation:
func Latitude(fl validator.FieldLevel) bool {
	latitude := fl.Field().Float()
	if latitude < -90 || latitude > 90 {
		return false
	}
	return true
}

func Longitude(fl validator.FieldLevel) bool {
	longitude := fl.Field().Float()
	if longitude < -180 || longitude > 180 {
		return false
	}
	return true
}
